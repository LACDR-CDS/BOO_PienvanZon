---
title: "BOO 2025 - Example Analysis"
subtitle: "Script 1: Data exploration - Questions"
date: "`r Sys.Date()`" 
author: 
  Student name
output:
  html_document:
    code_download: true
    theme: united
    highlight: tango
    df_print: paged
    toc: true
    number_sections: true
    toc_float:
      collapsed: false
      smooth_scroll: true
---

***

> In this script you will explore the project data, describing the variables and outlining the data structure. 

***

# Setup

## Using this template

For each of the steps in the BOO project, we have prepared an example script like this one. You can download the R markdown (.Rmd) file to make it easier to complete the steps.

**Exercise 1: Download the .Rmd using the `Code` dropdown menu in the top right corner of this document, and load it into R Studio.**

***

## Clean

It is good practice to clean your environment at the start of every script. That way all the objects you need for the analysis are loaded within the code, and the R markdown document will knit without issues. 

**Exercise 2: Remove all current objects from the R environment:**

<details>
  <summary><strong>Hint</strong></summary>

  `ls()` is a function that returns the names of all objects currently loaded into the session.

</details>

```{r clean}
# This gives a character of 0, thus the environment is clear
ls()

```

***

## Load packages

In R, different packages can have functions with the same name. Later loaded packages can therefore mask functions from earlier loaded ones. To avoid confusion when rerunning chunks within a script, we advise loading all required packages at the start. 

As you learned in the DataCamp course, `tidyverse` is a group of packages which includes many basic functions for data wrangling and visualization in R.

**Exercise 3: Load the `tidyverse` package into your environment:**

```{r load-packages}
# The tidyverse is already loaded.
library(tidyverse)

```

You can see from the reported message that loading `tidyverse` masks base R functions, `filter()` and `lag()`. If it is the case that a function you want to use is masked, you can always specify the package you intend to draw from explicitly using the `::` operator (e.g. `stats::filter()`).

***

## Set variables

Setting variables that you will use repeatedly in a script can save time if you need to make changes later. This can include paths to folders where you store files or QC thresholds, for example.

**Exercise 4: Create the following objects in your R environment:**

* `root_dir` - your project folder
* `count_path` - location of the count data
* `metadata_path` - location of the metadata (sample information)

```{r set-variables}
# the values are now in my environment
root_dir <- "C:/Users/pienz/Universiteit Leiden/BOO 2025 - BOO CDS Giulia team - BOO CDS Giulia team/Students/Pien/project/pienvanzon_BOO/"
count_path <- file.path(root_dir, "input", "countData.txt")
metadata_path<- file.path(root_dir, "input", "metaData.txt")

```

***

## Load data

**Exercise 5: Load the project data into your R environment:**

<details>
  <summary><strong>Hint</strong></summary>

  Use the `read_tsv()` function.

</details>

`countData`

* should contain one column `Probe` containing the probe names
* the rest of the columns should represent samples with values containing counts for that particular samples
* this object should have one row for each probe measured by the TempO-Seq

`metaData`

* should have a row for each of the sample columns in `countData`
* should have variables describing the samples in your data

```{r load-data}
# This reads the count data
countData <- read_tsv(count_path)

# This shows al the count data
str(countData)

#This reads the data from my file
metaData <- read_tsv(metadata_path)

#This shows the metaDat
str(metaData)
```

***

# Metadata

The `metaData` object contains information on the individual samples in the data.

**Exercise 6: Briefly describe each of the variables in `metaData`:**

```{r metadata}
# This gives the different names of the columns like sample_ID, sample_type,..
colnames(metaData)

# This gives the names of what comes under the columns, like the name of the sample, treatment or control, which compound,...
head(metaData)

```

***

**Exercise 7: What test system is this data profiled from? Give a brief description.**

<details>
  <summary><strong>Hint</strong></summary>

  Try looking at the `cell_type` variable.

</details>

```{r test-system}
# This function gives the cell type of the metaData which gives PHH
unique(metaData$cell_type)


```

***

**Exercise 8: How many treatment and control samples are there in the project data?**

```{r sample-type}
# This gives the output of the control and treatment. There are 18 controls and 42 treatments.
table(metaData$sample_type)

```

***

**Exercise 9: Describe the range of experimental conditions which the samples have been exposed to:**

<details>
  <summary><strong>Hint</strong></summary>

  Don't forget to describe the compounds and the concentration ranges.

</details>

```{r experimental-conditions}
# 
unique(metaData$compound_name)
table(metaData$compound_name, metaData$compound_class)

```
```{r}
metaData %>%
  select(compound_name, conc_amt, conc_unit, conc_ID, compound_class) %>%
  distinct()
  
```


***

**Exercise 10: How many replicates are there for each experimental condition?**

```{r replicate-number}
# In the last column replicates are shown. For example the compound 4-chloro-3-methylphenol has 3 replicates with a concentration of 0,03 ÂµM.
metaData %>%
  group_by(compound_name, conc_amt, conc_unit, conc_ID, compound_class) %>%
  summarise(n_replicates = n())

```

***

**Exercise 11: Are the compounds on different plates? If so, how might this affect the analysis and results? Has the experimental design been adjusted to compensate for this?**

```{r plates}
# The table shows that the 4-chloro-3-methylphenol on P6 is plated, just as its control DMSO. Laurylamine dipropylenediamine is plated on P4, just like its control, Medium.
table(metaData$compound_name, metaData$plate_ID)

```

***

**Exercise 12: Why do some samples not have data on their toxicity class?**

<details>
  <summary><strong>Hint</strong></summary>

  You can filter data using the `is.na()` function.

</details>

```{r na-class}
# The toxicity class is missing in the DMSO and Mdeium compounds, this is because they are not toxic. These are the controls and thus not relevant.
metaData_missing <- metaData %>% filter(is.na(compound_class))
metaData_missing
```

***

**Exercise 13: How many hours after exposure are the samples collected?**

```{r timepoint}
# The samples are collected after 24 hours.
unique(metaData$timepoint)

```

***

**Exercise 14: Check that each sample has a unique identifier:**

```{r unique-id}
# There are no duplicated, thus every sample ID is unique
anyDuplicated(metaData$sample_ID)

```

***

# Count data

The count data has information on raw counts from the probes measured during TempO-Seq (rows) in each of the samples (columns)

Many of the functions we will use in this project assume that `countData` row names are the gene or probe names. 

**Exercise 15: Change the variable `Probe` to the row names:**

<details>
  <summary><strong>Hint</strong></summary>

  Use the `column_to_rownames()` function.

</details>

```{r column-rownames}
# The table already has column and row names.

```

***

**Exercise 16: Which column in the metadata can be used to subset the count data? Use it to select only counts from the control samples:**

<details>
  <summary><strong>Hint</strong></summary>

  Make sure you don't replace `countData` with only control samples when answering this question! :)

</details>

```{r subset-controls}
# ??
unique(metaData$sample_type)

control_samples <- metaData$sample_ID[metaData$sample_type == "control"]
control_samples
countData_control <- countData[, control_samples]
countData_control
```

***

**Exercise 17: Check that the columns of the count data and rows of the metadata are in the same order.**

<details>
  <summary><strong>Hint</strong></summary>

  The different functionalities of `==` and `%in%` may help here.

</details>

```{r check-order}
# Checking if the columns of countData are sample_IDs and if the rows of the metaData are sample_IDs. It turns TRUE, so the sample_IDs are correctly in both sets
all(colnames(countData) %in% metaData$sample_ID)

# This checks if the data in both sets are the same order. It turns TRUE, so both sets match the sample_IDs in the correct order.
all(colnames(countData) == metaData$sample_ID) 


```

***

# Advanced question

This question provides a bit of a (hopefully fun) challenge, but you can also skip it, save your data, and move on to the probe QC if you prefer.

**Exercise 18: Make a plot of the plate layout using `ggplot`?**

<details>
  <summary><strong>Hint</strong></summary>

  Use `geom_tile()`

</details>

```{r plate-layout}
# 

```

***

# Save

Make sure you save any changed objects at the end of your script for downstream analysis.

**Exercise 19: Save your `countData` and `metaData` as `.Rdata` objects**

<details>
  <summary><strong>Hint</strong></summary>

  Don't forget to use `root_dir`, so if you ever move your project your code can be easily updated.

</details>

```{r save-data}
# 
save(countData, file=file.path(root_dir, "output/countData_01exploration.RData"))

```

***

# Session Info

Printing `session_info()` at the bottom of your scripts ensures your work is reproducible. It does this by keeping a record of the package versions used and the environment. 

**Exercise 20: Print your session info here:**

```{r session-info}
# 

```

***

**Exercise 21: Knit this script to produce either a `PDF` or `HTML`file and push it to your GitHub repository.**

That is the end of the Data Exploration. Example answers will be available from the `BOO_template` GitHub on Tuesday. 

Next, please move on to the probe QC using `02_ProbeQC_Outline.Rmd`.

***

